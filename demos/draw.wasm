config {
  memory.fixed: 1048576
}

import func sqrtF32(f32) f32;
import func sinF32(f32) f32;
import func cosF32(f32) f32;

import func flipBuffer(i32) void;


memory {
  align 4;
  phase: zero 4;

  align 4;
  frame_buffer: zero 262144;

  bitmap: hex
    0000000000000000
    0000ff0000ff0000
    0000ff0000ff0000
    0000000000000000
    ff000000000000ff
    00ff00000000ff00
    0000ffffffff0000
    0000000000000000;
}

func sampleBitmap(x f32, y f32) i32 {
  var xi i32 = i32(x * 8.0f);
  if (xi < 0) { return 0; }
  if (xi >= 8) { return 0; }
  var yi i32 = i32(y * 8.0f);
  if (yi < 0) { return 0; }
  if (yi >= 8) { return 0; }
  return i32(loadI8(bitmap + yi * 8 + xi));
}

func shade(x f32, y f32, t f32) i32 {
  var xOff f32 = x - 0.5f;
  var yOff f32 = y - 0.5f;
  var rsq f32 = xOff * xOff + yOff * yOff;
  var radius f32 = sqrtF32(rsq);
  var r f32 = cosF32(radius * 100.0f - t * 3.0f);
  var g f32 = x;
  var b f32 = y;
  var a f32 = 1.0f;
  if (sampleBitmap(x, y)) {
    r = 1.0f - r;
    g = 1.0f - g;
    b = 1.0f - b;
  }
  return packColor(r, g, b, a);
}

func f2b(v f32) i32 {
  var vi i32 = i32(v * 255.0f);
  if (vi < 0) {
    vi = 0;
  }
  if(vi > 255) {
    vi = 255;
  }
  return vi;
}

// Square root approximates gamma-correct rendering.
func packColor(r f32, g f32, b f32, a f32) i32 {
  return f2b(a) << 24 | f2b(sqrtF32(b)) << 16 | f2b(sqrtF32(g)) << 8 | f2b(sqrtF32(r));
}

func render() void {
  var p f32 = loadF32(phase);
  var y i32 = 0;

  while (y < 256) {
    var yAmt f32 = f32(y) / 256.0f;
    var x i32 = 0;
    while (x < 256) {
      var xAmt f32 = f32(x) / 256.0f;
      var color i32 = shade(xAmt, yAmt, p);
      storeI32(frame_buffer + (y * 256 + x) * 4, color);
      x = x + 1;
    }
    y = y + 1;
  }
  flipBuffer(frame_buffer);
}

export func frame(dt f32) void {
  storeF32(phase, loadF32(phase) + dt);
  render();
}

export func main() void {
  render();
}